package dunbar.c482pa.Controllers;

import dunbar.c482pa.Model.Inventory;
import dunbar.c482pa.Model.Part;
import dunbar.c482pa.Model.Product;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import java.io.IOException;
import java.net.URL;
import java.util.Optional;
import java.util.ResourceBundle;

/**The main window controller provides methods for loading and controlling the main window of the Inventory application
 *  GUI. This includes loading and populating the parts and products tables, implementing a search function for both
 *  tables, implementing a delete function for both tables, navigating to the Add and Modify Part and Product windows,
 *  and exiting the application. Implements the initialize method of the Initializable interface to load GUI elements on
 *  startup.*/
public class MainWindowController implements Initializable {
    /** Holds the main window to display scenes*/
    private Stage stage;
    /** Holds the scene for the window*/
    private Parent scene;
    /**Table column for part IDs*/
    @FXML
    private TableColumn<Part, Integer> partIDCol;
    /**Table column for part inventory*/
    @FXML
    private TableColumn<Part, Integer> partInvCol;
    /**Table column for part names*/
    @FXML
    private TableColumn<Part, String> partNameCol;
    /**Table column for part prices*/
    @FXML
    private TableColumn<Part, Double> partPriceCol;
    /**Table for all parts*/
    @FXML
    private TableView<Part> partTable;
    /**Text field for the Part table search bar*/
    @FXML
    private TextField partTableSearch;
    /**Table column for product IDs*/
    @FXML
    private TableColumn<Product, Integer> prodIDCol;
    /**Table column for product inventory*/
    @FXML
    private TableColumn<Product, Integer> prodInvCol;
    /**Table column for product names*/
    @FXML
    private TableColumn<Product, String> prodNameCol;
    /**Table column for product prices*/
    @FXML
    private TableColumn<Product, Double> prodPriceCol;
    /**Table for all products*/
    @FXML
    private TableView<Product> productTable;
    /**Text field for the Product table search bar*/
    @FXML
    private TextField productTableSearch;

    /** Loads the specified scene for a new window.
     * @param event An action even for a button press in the GUI
     * @param newAddress The package address for the desired FXML file*/
    private void changeWindowButton (ActionEvent event, String newAddress) throws IOException{
        stage = (Stage)((Button)event.getSource()).getScene().getWindow();
        scene = FXMLLoader.load((getClass().getResource(newAddress)));
        stage.setScene(new Scene(scene));
        stage.show();
    }

    /** Initializes and populates the Parts and Products tables when the main window is opened.
     * @param url The location used to resolve relative paths for the root object, or null if the location is not known.
     * @param rb The resources used to localize the root object, or null if the root object was not localized.*/
    @Override
    public void initialize(URL url, ResourceBundle rb) {
        partTable.setItems(Inventory.getAllParts());
        partIDCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        partInvCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        partNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        partPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));

        productTable.setItems(Inventory.getAllProducts());
        prodIDCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        prodInvCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        prodNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        prodPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));
    }

    /**Deletes a part from the Part table when a part is selected and the Delete button is pressed.
     * Done by invoking the Inventory deletePart() method.
     * @param event Event generated by pressing the Delete button*/
    @FXML
    void onActionDeletePart(ActionEvent event) throws NullPointerException {
        try {
            Part selectedPart = partTable.getSelectionModel().getSelectedItem();
            String deletedPart = selectedPart.getName();

            //Establishes a Yes/No confirmation button when a part is selected and the Delete button is pressed
            Alert confirmation = new Alert(Alert.AlertType.CONFIRMATION, "Delete part: " + deletedPart + "?");
            ButtonType yesButton = new ButtonType("Yes");
            ButtonType noButton = new ButtonType("No");
            confirmation.getButtonTypes().setAll(yesButton, noButton);
            Optional<ButtonType> result = confirmation.showAndWait();

            //If yes is selected, deletes the part.
            if(result.isPresent() && result.get() == yesButton) {
                if (Inventory.deletePart(partTable.getSelectionModel().getSelectedItem())) {
                    Alert alert = new Alert(Alert.AlertType.INFORMATION, deletedPart + " has been deleted");
                    alert.show();
                }
            }
        //Flags an error if the Delete button is pressed without a part selected
        } catch (NullPointerException noItemSelected) {
            Alert alert = new Alert(Alert.AlertType.ERROR, "Please select an item from the table to delete");
            alert.show();
        }
        partTable.getSelectionModel().clearSelection();
    }

    /**Deletes a product from the Product table when a product is selected and the Delete button is pressed.
     * Done by invoking the Inventory deleteProduct() method.
     * @param event Event generated by pressing the Delete button */
    @FXML
    void onActionDeleteProd(ActionEvent event) throws NullPointerException {
        String deletedProd = null;
        try {
            Product selectedProd = productTable.getSelectionModel().getSelectedItem();
            deletedProd = selectedProd.getName();

            //Flags an error if a part is associated with the selected Product
            if (!(selectedProd.getAllAssociatedParts().isEmpty())) {
                throw new Exception();
            }

            //Establishes a Yes/No confirmation button when a product is selected  and the delete button is pressed
            Alert confirmation = new Alert(Alert.AlertType.CONFIRMATION, "Delete product: " + deletedProd + "?");
            ButtonType yesButton = new ButtonType("Yes");
            ButtonType noButton = new ButtonType("No");
            confirmation.getButtonTypes().setAll(yesButton, noButton);
            Optional<ButtonType> result = confirmation.showAndWait();

            //If yes is selected, deletes the product
            if(result.isPresent() && result.get() == yesButton) {
                if (Inventory.deleteProduct(productTable.getSelectionModel().getSelectedItem())) {
                    Alert alert = new Alert(Alert.AlertType.INFORMATION, deletedProd + " has been deleted");
                    alert.show();
                }
            }

        //Flags an error if no product is selected and the Delete button is pressed.
        } catch (NullPointerException noItemSelected) {
            Alert alert = new Alert(Alert.AlertType.ERROR, "Please select an item from the table to delete");
            alert.show();
        } catch (Exception hasParts) {
            Alert alert = new Alert(Alert.AlertType.ERROR, "Product: " + deletedProd + " cannot be deleted due to associated parts");
            alert.show();
        }
        productTable.getSelectionModel().clearSelection();
    }

    /**Closes the application when the Exit button is pressed.
     * @param event Event generated by pressing the Exit button*/
    @FXML
    void onActionExit(ActionEvent event) {
        stage = (Stage)((Button)event.getSource()).getScene().getWindow();
        stage.close();
        System.exit(0);
    }

    /** Changes the application to the Add Part window when the Add part button is pressed.
     * @param event Event generated by pressing the Add part button*/
    @FXML
    void onActionToAddPartWindow(ActionEvent event) throws IOException{
        changeWindowButton(event, "/dunbar/c482pa/AddPartWindow.fxml");
    }

    /** Changes the application to the Add Product window when the Add product button is pressed.
     * @param event Event generated by pressing the Add product button*/
    @FXML
    void onActionToAddProdWindow(ActionEvent event) throws IOException{
        changeWindowButton(event, "/dunbar/c482pa/AddProductWindow.fxml");
    }

    /** Changes the application to the Modify Product window when the Modify product button is pressed.
     * @param event Event generated by pressing the Modify product button*/
    @FXML
    void onActionToModProdWindow(ActionEvent event) throws IOException, NullPointerException {
        try {
            //Invokes the ModifyProductWindowController loadProduct() method to populate the fields for the selected Product
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource("/dunbar/c482pa/ModifyProductWindow.fxml"));
            loader.load();
            ModifyProductWindowController mpwController = loader.getController();
            mpwController.loadProduct(productTable.getSelectionModel().getSelectedItem());

            //Loads the Modify Product window
            stage = (Stage) ((Button) event.getSource()).getScene().getWindow();
            Parent scene = loader.getRoot();
            stage.setScene(new Scene(scene));
            stage.show();
        }
        //Flags an error if the Modify button is pressed and no Product was selected.
        catch(NullPointerException noItemSelected) {
            Alert alert = new Alert(Alert.AlertType.ERROR,"Please select an item from the Product table to modify");
            alert.show();
        }
    }

    /** Changes the application to the Modify Part window when the Modify part button is pressed.
     * @param event Event generated by pressing the Modify part button*/
    @FXML
    void onActionToModifyPartWindow(ActionEvent event) throws IOException{
        try {
            //Invokes the ModifyPartWindowController loadPart() method to populate fields for the selected part
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource("/dunbar/c482pa/ModifyPartWindow.fxml"));
            loader.load();
            ModifyPartWindowController mpwController = loader.getController();
            mpwController.loadPart(partTable.getSelectionModel().getSelectedItem());

            //Loads the Modify Part Window
            stage = (Stage) ((Button) event.getSource()).getScene().getWindow();
            Parent scene = loader.getRoot();
            stage.setScene(new Scene(scene));
            stage.show();
        }
        //Flags an error when the Modify Part button is pressed without a part selected.
        catch(NullPointerException noItemSelected) {
            Alert alert = new Alert(Alert.AlertType.ERROR,"Please select an item from the Part table to modify");
            alert.show();
        }
    }

    /**Implements search and filtering functionality for the part table.
     * Every time a key is pressed in the part search text box, runs the appropriate Inventory lookupPart()
     * method based on the type of input (integer vs string) then filters the part table contents accordingly.
     * @param event Event generated by typing in the part search text box*/
    @FXML
    void onActionPartSearch(KeyEvent event) throws NumberFormatException{
        String search = partTableSearch.getText();
        int partID = 0;
        ObservableList<Part> filter = FXCollections.observableArrayList();  //Establishes a local filter list for the search.

        partTable.getSelectionModel().clearSelection();     //Clears any previous selections in the part table

        if(!(Inventory.getFilteredParts().isEmpty())){      //Clears the FilteredParts field from Inventory
            Inventory.getFilteredParts().clear();
        }

        try{
            //Attempts to run Inventory.lookupPart() using a part ID. If the input string cannot be parsed as an integer, throws an exception.
            partID = Integer.parseInt(search);
            if(!(Inventory.lookupPart(partID) == null)) {
                filter.add(Inventory.lookupPart(partID));
            }
        }
        //If the input was not an integer, runs Inventory.lookupPart() using a string instead.
        catch(NumberFormatException notInt) {
            filter = Inventory.lookupPart(search);
        }
        //Regenerates the part table using the filtered list. If the list is empty, outputs an error message.
        partTable.setItems(filter);
        partIDCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        partInvCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        partNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        partPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));
        if(filter.size() == 1){
            partTable.getSelectionModel().select(filter.get(0));
        }
        if(filter.size() == 0){
            Alert notFound = new Alert(Alert.AlertType.ERROR, "Item not found!");
            notFound.show();
        }
    }

    /**Implements search and filtering functionality for the product table.
     * Every time a key is pressed in the product search text box, runs the appropriate Inventory lookupProduct()
     * method based on the type of input (integer vs string) then filters the part table contents accordingly.
     * @param event Event generated by typing in the product search text box*/
    @FXML
    void onActionProductSearch(KeyEvent event) throws NumberFormatException {
        String search = productTableSearch.getText();
        int productID = 0;
        ObservableList<Product> filter = FXCollections.observableArrayList();   //Establishes a local filter list for the search.

        productTable.getSelectionModel().clearSelection();   //Clears any previous selections in the product table

        if(!(Inventory.getFilteredProducts().isEmpty())){   //Clears the FilteredParts field from Inventory
            Inventory.getFilteredProducts().clear();
        }
        //Attempts to run Inventory.lookupProduct() using a product ID. If the input string cannot be parsed as an integer, throws an exception.
        try{
            productID = Integer.parseInt(search);
            if(!(Inventory.lookupProduct(productID) == null)) {
                filter.add(Inventory.lookupProduct(productID));
            }
        }
        //If the input was not an integer, runs Inventory.lookupProduct() using a string instead.
        catch(NumberFormatException notInt) {
            filter = Inventory.lookupProduct(search);
        }
        //Regenerates the product table using the filtered list. If the list is empty, outputs an error message.
        productTable.setItems(filter);
        prodIDCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        prodInvCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        prodNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        prodPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));
        if(filter.size() == 1){
            productTable.getSelectionModel().select(filter.get(0));
        }
        if(filter.size() == 0){
            Alert notFound = new Alert(Alert.AlertType.ERROR, "Item not found!");
            notFound.show();
        }
    }

}